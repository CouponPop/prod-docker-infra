input {
  beats {
    port => 5044
  }
}

filter {
  # 1. 스택 트레이스 라인 및 Grok 실패 이벤트를 드롭하여 충돌 방지
  # Grok 실패 태그가 있거나, 메시지가 Java 스택 트레이스 라인(\tat 으로 시작)이면 드롭
  if ("_grokparsefailure" in [tags]) or ([message] =~ /^\s+at\s+/) or ([message] =~ /^\s+\.{3}\s+\d+\s+common frames omitted/) {
    drop {}
  }

  # 2. Grok 필터 적용 (Grok 실패 태그가 없는 경우에만 시도하도록 조건문 밖에 두는 것이 일반적입니다.)
  grok {
    match => { "message" => [
      # 이 Grok 패턴은 로그 메시지의 헤더(타임스탬프, 레벨 등)를 파싱하는 용도로만 사용됩니다.
      "^%{TIMESTAMP_ISO8601:log_timestamp}\s+%{LOGLEVEL:level}\s+%{NUMBER:pid}\s+---\s+\[%{DATA:service_name}\]\s+\[%{DATA:thread_name}\]\s+%{JAVACLASS:logger_name}\s+:\s+%{GREEDYDATA:log_message}"
    ]}
    # Grok 실패 태그가 붙어도 일단 다음 필터는 진행되므로, 1번 드롭 로직이 중요합니다.
  }

  # 3. Grok 실패 시 추가 필터 실행 방지 (기존 로직 수정)
  # Grok이 성공했을 때만 date, mutate 로직이 실행되도록 명확히 합니다.
  if ! ("_grokparsefailure" in [tags]) {
    date {
      match => [ "log_timestamp", "ISO8601" ]
      target => "@timestamp"
    }

    mutate {
      uppercase => [ "level" ]
      remove_field => [ "log_timestamp" ]
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://elastic:9200"]
    index => "logstash-%{+YYYY.MM.dd}"
  }

  # 디버깅용 콘솔 출력
  stdout {
    codec => rubydebug
  }
}